<plugin>

<!--<link rel="stylesheet" href="https://unpkg.com/skewt-plus/dist/skewt.css">    -->
<div class="sliding-x" data-ref="slidingX"></div>

<div id="radiosonde-container" class="plugin-content"  >

    <div class="desktab-heading size-xl" style="flex-grow:0;"><b>Radiosonde</b></div>
    <div class="mobile-title" style="flex-grow:0;">Radiosonde</div>
    <div class="page" data-ref="skewtPage">

        <div style="text-align:center"><b data-ref="titleMainPage"></b>&nbsp;&nbsp;&nbsp;<span data-ref="titleSynTime"></span></div>

        <div id="skewt-container" class="skew-t noselect"></div>

        <div class="settings" style="margin-top:10px">

            <div class="head">
                Available forecast model to compare:
            </div>

            <div data-ref="selProduct" style="min-height:30px;"><div data-ref="nomodel" style="pointer-events:none; cursor:auto; " class="select-product noselect">No Model available</div> </div>
            <div style="min-height:30px; ">
                <div style="display:inline-block;  margin-top:7px;" class="head">Highlight:</div>
                <span data-ref="highlight"></span>
            </div>

            <div style="display:flex; justify-content:space-between;">
                <div style="display:inline-block; line-height:28px">
                    <span class="head">Syn time:&nbsp;&nbsp;&nbsp;</span>
                    <span data-ref="synTime"></span>
                </div>
                <div data-ref="showAscents" class="select-product" style="width:120px; float:right;">Show Ascents</div>
            </div>

            <div data-ref="syntimeRangeCont">
                <input data-ref="syntimeRange" type="range" min="0"  max="100"  step="1">
                <div data-ref="syntimeMarkers"></div>
            </div>

            <div class="head toggle-section checkbox" onclick="this.classList.toggle('off');">Station detail:</div>
            <div  class="section-border-radiosonde" data-ref="detail2">No Ascent Selected</div>

            <div class="head toggle-section checkbox"  onclick="this.classList.toggle('off')">Download ascent:</div>
            <div data-ref="downloads"></div>
            <div data-ref="noAscSelected" class="select-product hidden">No ascent selected.</div>
            <br><br>

            <!--  This will be appended to the skew-t extra settings -->
            <div class="head toggle-section checkbox" data-ref="extraSettings" onclick="this.classList.toggle('off');">Extra settings:</div>

        </div>
    </div>

    <div class="page" style="display:none;"  data-ref="ascentsPage">
        <div><b data-ref="titleAscentPage">Title</b></div>
        <div data-ref="ascentsContent" style="min-height:calc(100% - 25px);" ></div>
        <div data-ref="ascentsClose" class="select-product" style="width:120px;  position:sticky; bottom:5px; float:right;  display:block">Close</div>
    </div>

</div>

<div class="bottom-border-mobile">a</div>
<div class="closing-x collapse-pane"></div>

<div class="drag-right-border" data-ref="rightBorder">
    <div class="right-border-line hidden"></div>
    <div class="inside-button"></div>
</div>


<script>

    let aobj={a:1,b:2};
    for (let p in aobj){
        console.log(p);
        document.addEventListener("keydown", k=>{
            if(k.key == p) console.log(p);
        });
    }

    import $ from '@windy/$';
    import map from '@windy/map';
    import picker from '@windy/picker';
    import rs from '@windy/rootScope';
    import bcast from '@windy/broadcast';
    import Drag from '@windy/Drag';
    import _ from '@windy/utils';
    import store from '@windy/store';
    import allPlugins from '@windy/plugins';
    import Color from '@windy/Color';
    import models from '@windy/models';
    import lruCache from '@windy/lruCache';

    import Switch from '@windy/Switch';
    import BottomSlide from '@windy/BottomSlide';
    import ib from './infobox.mjs';
    import downloadObjAs from './download.mjs';
    import pickerTools from './pickerTools.mjs';

    //import getForecast from './getForecastW.mjs';
    import getForecast from './getForecast.mjs';


    let earliestAirDataTime;      //get earliest time where forecast data is avaialble,  with promise.all once summary loaded,  show only the markers with forecast avail

    const thisPlugin=this;

    const dayMs=1000*60*60*24;
    const h1=1000*60*60;
    const availProd=models.overlay2product.temp;

    let maxAge=168; //hours in a week.
    let reqAge=9;
    let prevColor, selMarker;   //selMarker refers to the selected marker object.
    let selPressure;

    let link2ts = false;

    let markers=[];  //array containing all the markers,  and associated leaflet layers,  and index of current syn time selected
    let prodSel="ecmwf", coordSel, ixSel;

    let prodBtns={};
    let prodData={};
    let sondeData=[];
    let selAscent;  //selected ascent geoJSON.
    let surElev;
    let pickerPos=null;
    let newW = 350;

    let sondeinfo;   //info data field codes

    //use internal windy lruCache, to cache airdata and ascents.
    let ascCache = new lruCache(200); //cache 200 ascents
    let airDataCache = new lruCache(100);

    const datapath="https://radiosonde.mah.priv.at/data/";
    const summary_br = 'summary.geojson.br';
    let summaryFmt;



    //-- add windy style checkbox to skewt and add make extra settings collapsible

    const skewt=new SkewT("#skewt-container", rs.isMobileOrTablet);

    let cbCont = $('.checkbox-container',$("#skewt-container"));
    let skewtCb=$('input[type="checkbox"]',cbCont);
    skewtCb.style.display="none";
    let skewtCbT=$('.skewt-checkbox-text',cbCont);
    skewtCbT.classList.add("noselect","inlined");
    let windyCb = document.createElement("span");
    windyCb.classList.add("checkbox","off");
    cbCont.insertBefore(windyCb,skewtCbT);
    windyCb.addEventListener("click", () => {
        skewtCb.click();
        windyCb.classList.toggle("off");
    });

    let extraSetCont= $(".range-container-extra",  $('#skewt-container'));
    extraSetCont.classList.add("section-border-radiosonde");
    $('#skewt-container').insertBefore(this.refs.extraSettings,extraSetCont);
    extraSetCont.style.padding="3px 0px 3px 3px";




    //--opening and closing

    this.active = () => document.body.classList.contains("radiosonde-plugin-active");

    this.onopen = () => {
        if (this.active()) return;
        document.body.classList.add("radiosonde-plugin-active");
        //console.log(markers);
        if (sondeinfo) summaryPromise().then(handleAgeRangeInput);
        markers=[];
        this.refs.infobox.style.display=null;
        W.plugins.detail.className="detail bottom-border left-border";
        W.plugins.detail.exclusive="";
        bcast.on("pluginOpened",detailOpened);
        bcast.on("pluginClosed",detailClosed);
    }

    this.onclose = message => {   //message=="unmount":  Plugin closed.   All layers removed from map.  Listeners off.
        console.log(message);
        if (message!="unmount") return;
        document.body.classList.remove("radiosonde-plugin-active");

        //remove all map elements and set markers=[]
        markers.forEach( removeMarker );
        markers=[];
        this.refs.infobox.style.display="none";
        lineMarker.remove();
        ghostMarker.remove();

        W.plugins.detail.className="detail bottom-border";
        W.plugins.detail.exclusive="all";

        bcast.off("pluginOpened",detailOpened);
        bcast.off("pluginClosed",detailClosed);
        map.off("click",mapClick4Detail);  //in case detail stays open
    }



    $(".closing-x:not(.collapse-pane)",thisPlugin.element).addEventListener("click",()=>thisPlugin.close("unmount"));


    //--marker properties and colors

    //place markers in a custom pane that is ontop of labelslayer
    //when picker is openened,  append to the picekr marker DOM element to the popup pane.

    let sondeMarkerPane = map.createPane("sondeMarkerPane");
    sondeMarkerPane.style.zIndex=610;

    function timeString(unxiTimestamp) {
        var ts = new Date(unxiTimestamp * 1000).toJSON();
        return ts.substring(0, 10) + ' ' + ts.substring(11, 16) + 'Z';
    }
    function minsec(sec) {
        if (sec < 60) return sec + " sec";
        var m = sec / 60;
        return Math.round(m) + " min";
    }

    const findNearestPoint=(e,ar)=>{  //use sondeData and e is latlng of event
        let i=ar.reduce( (ac,n,i) => {
            let r = (n.lat-e.lat)*(n.lat-e.lat)+(n.lng-e.lng)*(n.lng-e.lng);
            return r<ac.r? {i,r}: ac;
        }, {i:-1,r:Infinity}).i;
        return ar[i];
    }

    const findNearestIndex=(e,ar)=>{
        return ar.reduce( (ac,n,i) => {
            let dlt = n.lat-e.lat, dln = n.lng-e.lng,  r = dlt*dlt+dln*dln;
            return r<ac.r? {i,r}: ac;
        }, {i:-1,r:Infinity}).i;
    }

    const findPointWithPressure=(p,ar)=>{
        let i=ar.reduce( (ac,n,i) => {
            let r = Math.abs(n.press-p);
            return r<ac.r? {i,r}: ac;
        }, {i:-1,r:Infinity}).i;
        return ar[i];
    }

    skewt.setCallback(p=>{
        selPressure=p;
        let {lat,lng}=findPointWithPressure(p,sondeData);
        if (lat!==void 0 && lng!==void 0) lineMarker.setLatLng({lat,lng});
    });


    //--ghost marker and black spot
    const onGhostDrag=(latlng)=>{
        if (selMarker && selMarker.boatPath){       //if boat 1st check if not maybe closer to another boat position.
            let i= findNearestIndex(latlng, selMarker.boatPath._latlngs)
            if (selMarker.i!=i){
                selMarker.i=i;
                selMarker.circle.fire("click");
                return;
            }
        }
        if (sondeData) {
            let n=findNearestPoint(latlng, sondeData);
            lineMarker.setLatLng(n);
            skewt.showTooltips();
            selPressure=n.press;
            skewt.move2P(selPressure);
        }
    }

    let ghostDiv = L.divIcon({className:"transparent-marker-container", html:'<div style="position:absolute; left:0px; top:0px; height:20px; width:20px; background-color:rgba(0,0,0,0);"></div>',  iconAnchor:[10,10], iconSize:[0,0]});
    let ghostMarker = L.marker([0,0],{icon:ghostDiv,  zIndexOffset:5000,  draggable:true, pane:sondeMarkerPane})
        .on("drag", e=>onGhostDrag(e.latlng))
        .on("click", e=>{
            onGhostDrag(map.mouseEventToLatLng(e.originalEvent)); //clicking only sends markers latlng and not click position.
        })
        .on("dragend",e=>{
            //console.log("dragend",  e.latlng);
            if (sondeData){
                ghostMarker.setLatLng(findNearestPoint(lineMarker.getLatLng(), sondeData));
            }
        });
        //.addTo(map);

    let markerDiv = L.divIcon({className:"transparent-marker-container",html:'<div style="position:absolute; left:0px; top:0px; border-radius:5px; height:5px; width:5px; background-color:black;"></div>',  iconAnchor:[3,3], iconSize:[0,0]});
    let lineMarker = L.marker([0,0],{icon:markerDiv, zIndexOffset:3000,  pane:sondeMarkerPane});
    //.addTo(map);

    ////to debug
    //let temp1 = L.circleMarker([0,0],{radius:5, weight:2, color:"red"}).addTo(map)
    //let temp2=   L.circleMarker([0,0],{radius:5, weight:2, color:"green"}).addTo(map)


    ////function to obtain pressure,  from surface pressure,  from provided pressure and gh

    function getElevation2(p, refp=1013.25){   //pressure altitude with NOAA formula  (https://en.wikipedia.org/wiki/Pressure_altitude)
        return    145366.45 * (1 - Math.pow(p/ refp, 0.190284) ) / 3.28084 ;
    }

    function pressureFromElevation(e, refp=1013.25){
        e = e*3.28084;
        return Math.pow((-(e/145366.45 - 1)), 1/0.190284) * refp;
    }

    function getSurfaceP(surfElev, refElev = 110.8, refP = 1000){  //calculate surface pressure at surfelev,   from reference elev and ref pressure.
        let expectElev = getElevation2(refP);
        let elevD = surfElev - refElev;
        return pressureFromElevation(elevD, refP);
    }



    //--colors
    var viridisStops = ['#440154', '#482777', '#3F4A8A', '#31678E', '#26838F', '#1F9D8A', '#6CCE5A', '#B6DE2B', '#FEE825'];

    function hex2RgbA(a){
        return a.match(/#(..)(..)(..)/).filter((n,i)=>i).map(n=>parseInt(n,16)).concat(0);
    }

    let ageColorsInstance, ageColors,  getAgeColor;

    const initColors = () => { //depends on maxAge,
        let ii=Math.floor(maxAge/(viridisStops.length-1));
        ageColorsInstance = Color.instance({
            ident: 'ageColors',
            steps: 1024,
            default: viridisStops.slice(0).reverse().map((a,i)=>[i*ii,hex2RgbA(a)])
        });
        ageColors = ageColorsInstance.getColor.call(ageColorsInstance);
        getAgeColor = (age, opacity) => {  //age in hours
            const [R, G, B] = ageColors.RGBA.call(ageColors, age);
            return `rgba(${R},${G},${B}, ${opacity})`;
        };
    }

    //--product switch and forecast/radiosonde switch
    availProd.forEach(p=>{
        let td=document.createElement("div");
        td.classList.add("select-product","hidden");
        td.dataset.do=`set,${p}`;
        td.innerHTML=p;
        this.refs.selProduct.appendChild(td);
        prodBtns[p]=td;
        prodData[p]=[];
    });

    let prodSwitchClicked=false;
    let prodSwitch = Switch.instance({
        el:this.refs.selProduct,
        initValue:"ecmwf",
        onset: value=>{
            skewt.removePlot(prodData[prodSel]);
            prodSel=value;
            prodSwitchClicked=true;
            store.set("product",prodSel);
            if(!pickerPos) skewt.plot(prodData[prodSel],{add:true});
            //makeCloudsFromProd(prodSel);  now done in skewt
            highlightswitch.onset(highlightswitch.selected);
        }
    });

    ["Radiosonde","Forecast"].forEach(p=>{
        let td=document.createElement("div");
        td.classList.add("select-product");
        if(p=="Forecast"){
            td.classList.add("hidden");
            this.refs.selectForecast=td;
            //console.log(this.refs.selectForecast)
        }  else {
            this.refs.selectSonde=td;
        }
        td.dataset.do=`set,${p}`;
        td.innerHTML=p;
        this.refs.highlight.appendChild(td);
    })

    let highlightswitch=Switch.instance({
        el:this.refs.highlight,
        initValue:"Radiosonde",
        onset: value=>{
            skewt.selectSkewt(value=="Radiosonde"?sondeData:prodData[prodSel]);
            //console.log(selPressure);
            if(selPressure){
                //console.log(selPressure);
                skewt.showTooltips();
                skewt.move2P(selPressure);
            }
        }
    });

    this.refs.showAscents.addEventListener("click", e=>{
        this.refs.ascentsPage.style.display="block";
        this.refs.skewtPage.style.display="none";
    });

    this.refs.ascentsClose.addEventListener("click", e=>{
        this.refs.ascentsPage.style.display="none";
        this.refs.skewtPage.style.display="block";
    });

    this.refs.syntimeRange.addEventListener("input",e=>{
        let {id,ascAr,min,max,dif,lat,lon,rangeMarkerAr,marker}=timeRangeVals;
        if(!ascAr || !ascAr.length) return;

        let r=this.refs.syntimeRange;

        let n=min + dif * r.value/100;
        let i=ascAr.reduce((a,b,i) => Math.abs((b.syn_timestamp) - n) < Math.abs(a.v-n)?{v:b.syn_timestamp,i}:a, {v:-Infinity,i:-1}).i;

        if (i!=marker.i){
            marker.i=i;
            rangeMarkerAr.forEach((m,ii)=>{
                m.classList[i==ii?"add":"remove"]("ascent-marker-highlight");
            })

            //console.log(ascAr[i].syn_timestamp.toJSON());
            this.refs.synTime.innerHTML=new Date(ascAr[i].syn_timestamp*1000).toJSON().slice(0,16)+"Z";
            //console.log("call plot from range");
            plotSonde(id,ascAr[i]);
        }
    });


    ["CSV","GeoJSON"].forEach(type=>{
        let dv=document.createElement("div");
        dv.classList.add("select-product");
        dv.innerHTML=type;
        dv.addEventListener("click",()=>{
            if (!selAscent){
                this.refs.noAscSelected.classList.remove("hidden");
                setTimeout(()=>this.refs.noAscSelected.classList.add("hidden"),  1000 );
            } else {
                downloadObjAs(type, selAscent);
            }
        })
        this.refs.downloads.appendChild(dv);
    });


    //--infobox with age slider
    this.refs.infobox = ib(
        `
        <div id="open-radiosonde-plugin" class='radiosonde-button inlined' data-icon='d' >Radiosonde</div>
        <div id="radiosonde-zoom"  class='radiosonde-button hidden'>Zoom in on marker</div>`

        //+
        //`<div id="radiosonde-link-timestamp" class='radiosonde-button'>Click to link Calendar</div>`
        +`
        <div id="radiosonde-age-value" class='radiosonde-button'></div>
        <div id="radiosonde-range-container">
            <input id="radiosonde-range" type="range" min="0" max="168" step="1">
        </div>
        `
        , "open-radiosonde-plugin" //id of the button which will open the left hand pane
        , this  //reference to this plugin
        , rs.isMobile?true:false  //true = hide this box when plugin opens
        //optionally send fx
    )

    bcast.on("pluginOpened",e=>{if (e==this.ident) $("#open-radiosonde-plugin").classList.add("hidden") });
    bcast.on("pluginClosed",e=>{if (e==this.ident) $("#open-radiosonde-plugin").classList.remove("hidden") });

   /*
    $("#radiosonde-link-timestamp").addEventListener("click",()=>{
        link2ts=true;
        $("#radiosonde-age-value").classList.add("grey");
        $("#radiosonde-age-value").innerHTML="Click to set age";
        $("#radiosonde-link-timestamp").classList.remove("grey");
        $("#radiosonde-link-timestamp").innerHTML="Linked to Calendar";
        $("#radiosonde-range-container").classList.add("hidden");
        handleTs(store.get("timestamp"));
    });
    $("#radiosonde-age-value").addEventListener("click",()=>{
        link2ts=false;
        handleAgeRangeInput();
        $("#radiosonde-age-value").classList.remove("grey");
        $("#radiosonde-link-timestamp").classList.add("grey");
        $("#radiosonde-link-timestamp").innerHTML="Click to link Calendar";
        $("#radiosonde-age-value").innerHTML=`Newer than ${reqAge} hrs`;
        $("#radiosonde-range-container").classList.remove("hidden");
    })
    */
    $("#radiosonde-zoom").addEventListener("click",()=>{
        if (selMarker)  map.setView(selMarker.circle._latlng,8);
        else if (pickerPos) map.setView([pickerPos.lat,pickerPos.lon],8);
    })

    $("#radiosonde-range-container").style.background=`linear-gradient(90deg,${viridisStops.join(",")})`;


    const removeMarker=(m)=>{
        m.circle.remove();
        if (m.line)      m.line.remove();
        if (m.ghostline) m.ghostline.remove();
        if (m.boatPath)  m.boatPath.remove();
        if (m.boatPathGhost)  m.boatPathGhost.remove();
        if (m==selMarker){
            //console.log("selected Marker removed");
            skewt.clear();
            skewt.hideTooltips();
            selMarker=null;
            $("#radiosonde-zoom").classList.add("hidden");
        }
    }

    const addMarker=(m)=>{
        m.circle.addTo(map);
        if (m.line)      m.line.addTo(map);
        if (m.ghostline) m.ghostline.addTo(map);
        if (m.boatPath)  m.boatPath.addTo(map);
        if (m.boatPathGhost)  m.boatPathGhost.addTo(map);
    }

    const handleAgeRangeInput = () => {
        reqAge= maxAge - $("#radiosonde-range").value;
        $("#radiosonde-age-value").innerHTML =  `Newer than ${reqAge} hrs`;
        markers.forEach(m=>{
            if(m.age<reqAge){
                addMarker(m);
            } else {
                removeMarker(m);
            }
        });
    }

    const handleTs = ts => {
        markers.forEach(m=>{
            let found=null;
            if (m.ascAr[0].syn_timestamp > ts/1000 - 90*60){
                for (let i=0; found==null && i<m.ascAr.length; i++){
                    let d= Math.abs(m.ascAr[i].syn_timestamp-ts/1000);
                    if (d< 90*60) {
                        found=i;
                    }
                }
            }
            if (found!==null) {
                m.i=found;
                if(m.circle._icon)m.circle._icon.classList.add("big-marker");

            } else {
                if(m.circle._icon)m.circle._icon.classList.remove("big-marker")
            }
        })
    }
    store.on("timestamp", handleTs);

    $("#radiosonde-range").addEventListener("input", handleAgeRangeInput);

    //-- draw circles

    const source_map = {
        netCDF: "madis/",
        BUFR: "gisc/",
        madis: "madis/",
        gisc: "gisc/"
    };

    function dataURI(sid, ascent) {
        var ts = new Date(ascent.syn_timestamp * 1000).toJSON();
        if (summaryFmt < 4) {
            return datapath +
                source_map[ascent.source] +
                sid.substring(0, 2) + "/" +
                sid.substring(2, 5) + "/" +
                sid + "_" +
                ts.substring(0, 4) +
                ts.substring(5, 7) +
                ts.substring(8, 10) + "_" +
                ts.substring(11, 13) +
                ts.substring(14, 16) +
                ts.substring(17, 19) +
                ".geojson";
        };
        if (summaryFmt < 6) {
            return datapath +
                source_map[ascent.source] +
                sid.substring(0, 2) + "/" +
                sid.substring(2, 5) + "/" +

                ts.substring(0, 4) + "/" +
                ts.substring(5, 7) + "/" +

                sid + "_" +
                ts.substring(0, 4) +
                ts.substring(5, 7) +
                ts.substring(8, 10) + "_" +
                ts.substring(11, 13) +
                ts.substring(14, 16) +
                ts.substring(17, 19) +
                ".geojson";
        }
        return datapath +
            ascent.repfmt + "/" +
            sid.substring(0, 2) + "/" +
            sid.substring(2, 5) + "/" +

            ts.substring(0, 4) + "/" +
            ts.substring(5, 7) + "/" +

            sid + "_" +
            ts.substring(0, 4) +
            ts.substring(5, 7) +
            ts.substring(8, 10) + "_" +
            ts.substring(11, 13) +
            ts.substring(14, 16) +
            ts.substring(17, 19) +
            ".geojson";
    }

    function hotfix(geojson) {

        // bring legacy detail files up to current fmt -
        // fix geojson objects in-place depending on various bug conditions:

        var fix_u_v = ((geojson.properties.repfmt === 'fm35') &&
            (geojson.properties.fmt < 5));

        var fix_pressure = ((geojson.properties.repfmt === 'fm94') &&
            (geojson.properties.fmt < 2));

        // walk the object and apply any fixes known for this version
        for (var i in geojson.features) {
            var p = geojson.features[i].properties;

            // pre-V2 BUFR files had pressure in Pa
            // make it hPa
            if (fix_pressure) {
                p.pressure = p.pressure * 0.01;
            }

            // pre-V5 netCDF files had u,v in knots
            // make it m/s
            if (fix_u_v) {
                if (typeof p.wind_u !== "undefined") {
                    p.wind_u = p.wind_u / 1.94384;
                }
                if (typeof p.wind_v !== "undefined") {
                    p.wind_v = p.wind_v / 1.94384;
                }
            }
        }
        // set the fmt to the current fmt so this is
        // idempotent
        geojson.properties.fmt = summaryFmt;

        //console.log("fix_u_v", fix_u_v);
        //console.log("fix_pressure", fix_pressure);
    }

    const windDirection = (x,y) => ((Math.PI + Math.atan2(x,y))*180/Math.PI)%360;

    const geodesicDir = (p1,p2) =>{
        let tr=Math.PI/180;
        let lat1=p1.lat*tr, lat2=p2.lat*tr, lon1=(p1.lon||p1.lng)  *tr, lon2=(p2.lon||p2.lng)  *tr;
        //console.log(lat1,lon1,lat2,lon2);
            const y = Math.sin(lon2-lon1) * Math.cos(lat2);
            const x = Math.cos(lat1)*Math.sin(lat2) -  Math.sin(lat1)*Math.cos(lat2)*Math.cos(lon2-lon1);
            const theta = Math.atan2(y, x);
            let dir = (theta/tr + 360) % 360;
            //console.log(dir);
        return dir;
    }


    const makeAirKey=(lat,lon,model,reftime)=>{
        let k=`${lat.toFixed(2)}_${lon.toFixed(2)}_${model}_${reftime}`;
        //console.log(k);
        return k;
    }


    let throttle = (function(){         //needs refinement to manage multiple different functions,  thus cache of functions
        let ready=true, to=null, args, fun;   //to = timeout
        return function(f, iv, delayStart){
            args = Array.prototype.slice.call(arguments).slice(3);
            fun = f;

            if(delayStart && to===null) {
                ready=false;
                to=setTimeout(()=>ready=true, iv);
            }

            if (ready){
                fun.apply(null, args);
                ready=false;
                clearTimeout(to);
                setTimeout(()=>{
                    ready=true;
                    to=setTimeout(()=>{
                        fun.apply(null,args);
                        to=null;
                    },iv);
                },iv)
            }
        }
    })()


    const getAirData=(product, syntime, lat, lon, add, ar)=>{

        let key = makeAirKey(lat,lon,product);

        return new Promise((res,rej)=>{
            let val= airDataCache.get(key);
            if (val){   //must still validate refTime.
                res(val);
            } else {
                res(
                    getForecast(product, lat, lon)
                    .then(d =>{
                        airDataCache.put(key,d);
                        return d;
                    })
                )
            }
        })
        .then(data=>{

            //find time
            let mindif=Infinity,ix;
            let lasth=0;
            data.data.data.hours.forEach((h,i)=>{
                let d=Math.abs(h-syntime);
                if (d<mindif){
                    mindif=d; ix=i;
                }
            });

            if (ix || mindif < h1*3) {

                let ar2=[];
                let d=data.data.data;

                if (data.data.header.elevation!==void 0)  surElev = data.data.header.elevation;

                for (let p in d){
                    let prop=p.match(/(.*?)-(.*?)(h|$)/);
                    if (prop){
                        //console.log("prop2",prop[2]);
                        if(prop[2]=="surface") prop[2]=1013.25;
                        if (prop[1]=="dewpoint"){
                            ar2.push({press:+prop[2], dwpt:d[p][ix]-273.15});
                        } else if (prop[1]=="gh"){
                            ar2.find(a=>a.press==+prop[2]).hght=d[p][ix];
                        } else if (prop[1]=="rh"){
                            ar2.find(a=>a.press==+prop[2]).rh=d[p][ix];
                        } else if (prop[1]=="temp"){
                            ar2.find(a=>a.press==+prop[2]).temp=d[p][ix]-273.15;
                        }  else if (prop[1]=="wind_u"){
                            ar2.find(a=>a.press==+prop[2]).u=d[p][ix];
                        } else if (prop[1]=="wind_v"){
                            ar2.find(a=>a.press==+prop[2]).v=d[p][ix];
                        }
                    }
                }

                ar2.forEach(e=>{
                    e.wdir=windDirection(e.u, e.v);
                    e.wspd=Math.sqrt(e.u*e.u+e.v*e.v);
                });

                ar2.sort((a,b)=>b.press-a.press);

                ar2.forEach(e=> e.hght = e.hght||getElevation2(e.press) );

                let surIx = ar2.findIndex(a=>a.hght>surElev);

                ar2[0].press = getSurfaceP(surElev, ar2[surIx].hght , ar2[surIx].press);
                ar2[0].hght = surElev;
                ar2[0].flags = 131072;

                let removed=ar2.splice(1, surIx-1);

                prodData[product]=ar2;

                prodBtns[product].classList.remove("hidden");
                this.refs.selectForecast.classList.remove("hidden");

                this.refs.nomodel.classList.add("hidden");
                //console.log(ar2);

                if (prodSel == product)  {
                    skewt.plot(ar2,{add, ixShift: add?0:1});
                    //throttle(makeCloudsProd, 500,  false, ar2);
                }

            } else {

                //airdataAvail=false;
            }

            return;
        }).catch(e=>{
            console.log("ERROR",e)
            return;
        });
    }

    const getPointProductsAr=(coordSel)=>{

            let pp=models.getPointProducts(coordSel);
            let pointprods = pp.filter(e=>availProd.indexOf(e)!=-1);
            if (pointprods.indexOf("icon")==-1)pointprods.push("icon");
            /// if iconEu available,  "icon" is excluded,  since I think iconEU is perhaps better.  Add it anyway.

            return pointprods;
    }

    const plotSonde=(id, asc, onlyPath=false)=>{ //onlyPath==true,  fetch the path and attach to the marker,  but do not plot the sonde

         //check if boat,  then update marker position and dir;
         if (selMarker && selMarker.boatPath){
            let {i,ascAr, circle} = selMarker;
            circle.setLatLng([ascAr[i].lat,ascAr[i].lon]);
            if(i==ascAr.length-1) i-=1;
            circle._icon.firstElementChild.style.transform=`rotate(${ geodesicDir(ascAr[i+1], ascAr[i])}deg)`;
        }

        let key=dataURI(id,asc);

        new Promise((res,rej)=>{
            let val= ascCache.get(key);
            if (val){
                res(val);
            } else {
                res(fetch(key)
                    .then(r=>r.json())
                    .then(d =>{
                        ascCache.put(key,d);
                        return d;
                    })
                )
            }
        }).then(d=>{

            hotfix(d);//temp and pressure fix

            selAscent=d;  //ref to last selected sonde original geojson for download purposes

            //console.log(d);

            //clear canvas2
            let cntx = skewt.cloudRef2.getContext('2d');
            cntx.clearRect(0, 0, skewt.cloudRef2.width, skewt.cloudRef2.height);

            if (!onlyPath){
                let str="More Detail: <br><div style='font-size:8px'>";
                for (let p in d.properties){
                    str+=`<b>&nbsp;&nbsp;${p}:</b> ${d.properties[p]}<br>`
                }
                str+="</div>";
                //this.refs.detail2.innerHTML=str;
                d.properties.station_name=selMarker.name;
                genDetail(d, this.refs.detail2);
                $("#radiosonde-zoom").classList.remove("hidden");
            }

            let ar = d.features.filter(f=>(f.geometry.type=="Point" && f.properties.temp !== void 0  && f.properties.pressure !== void 0  )).map(f=>{

                let p=f.properties;
                let temp=p.temp-273.15;
                let dwpt=p.dewpoint-273.15;
                let hght=p.gpheight;
                let press=p.pressure;
                let wdir=0,wspd=0;
                if (p.wind_u && p.wind_v){
                    wdir=windDirection(p.wind_u, p.wind_v);
                    wspd=Math.sqrt( p.wind_u*p.wind_u + p.wind_v*p.wind_v );
                }
                let time=p.time;
                let flags=p.flags;
                let [lng,lat] = f.geometry.coordinates;
                return {lng,lat,temp,dwpt,hght,press,wdir,wspd,time,flags};
            });

            let syntime=d.properties.syn_timestamp*1000;
            if (!onlyPath) this.refs.titleSynTime.innerHTML=new Date(syntime).toJSON().slice(0,16).replace("T","  ")+"Z";

            /////draw polyline
            let marker = markers.find(m=>m.id==id);
            //console.log(markers, marker);

            marker.data=ar;

            if (!marker.line) {
                marker.line = L.polyline(ar, {interactive:false, color:'white', weight:1, pane:sondeMarkerPane }).addTo(map);
                marker.ghostline = L.polyline(ar, {interactive:true,  bubblingMouseEvents:false,  color:'rgba(255,255,255,0.1)', weight:13, pane:sondeMarkerPane })
                .addTo(map)
                .bringToFront()
                .on('click', e=>{
                    if (sondeData!=marker.data){
                        marker.circle.fire("click");
                    }
                    ghostMarker.addTo(map);
                    lineMarker.addTo(map);
                    ghostMarker.setLatLng(e.latlng);
                    lineMarker.setLatLng(e.latlng);
                });
            } else { //alreayd created set coords.
                marker.line.setLatLngs(ar);
                marker.ghostline.setLatLngs(ar);
            }

            marker.line.bringToFront();
            marker.ghostline.bringToFront();


            if(!onlyPath){
                sondeData=marker.data;
                ghostMarker.addTo(map);
                lineMarker.addTo(map);
                ghostMarker.setLatLng(sondeData[0]);
                lineMarker.setLatLng(sondeData[0]);
                skewt.clear();  //just in case,  should not be necessary
                skewt.plot(marker.data);
                sondeData=marker.data;
                return {syntime,lat:ar[0].lat,lon:ar[0].lng};
            } else return {};

        }).then(({syntime,lat,lon,ar})=>{


            if (!syntime) return;

            let pointprods=getPointProductsAr(coordSel);

            for (let p in prodBtns) {
                prodBtns[p].classList.add("hidden");
                prodData[p]=[];//clear all previous data arrays;
            }

            this.refs.selectForecast.classList.add("hidden");
            this.refs.nomodel.classList.remove("hidden");
            highlightswitch.set("Radiosonde");

            const getNextProd = (i) =>{
                getAirData(pointprods[i],syntime,lat,lon,true).then(()=>{
                    if (++i<pointprods.length) getNextProd(i);
                })
            }
            getNextProd(0);
        })
    }


    let timeRangeVals={};

    const deselectSelMarker=()=>{
        if (selMarker && selMarker.circle &&  selMarker.circle._icon){
            selMarker.circle._icon.firstElementChild.classList.remove("active-marker");
        }
        selMarker=null;
        this.refs.selectSonde.classList.add("hidden");
        lineMarker.remove();
        ghostMarker.remove();
    }

    ////load all the summary:

    let summaryPromise = () => fetch(datapath+"summary.geojson").then(r=>r.json()).then(sum=>{

        console.log(sum);

        summaryFmt = sum.properties.fmt;

        initColors();

        sum.features.forEach(d=>{

            let [lng,lat]=d.geometry.coordinates;

            let ascAr = d.properties.ascents;

            let age= (Date.now()/1000 - ascAr[0].syn_timestamp)/3600;

            let isBoat = ascAr[0].lat !== void 0  && ascAr.length > 1;

            let sondeDivIcon;

            if (isBoat) {
                let dir  = geodesicDir(ascAr[1], ascAr[0]);
                sondeDivIcon=L.divIcon({className:"transparent-marker-container",
                    html:`
                        <svg viewbox="0 0 20 20" class="sonde-marker-icon boat"
                            style="fill:${getAgeColor(age,0.5)}; stroke:black;   stroke-width: ${ascAr[0].repfmt=='fm94'?2:1}; transform:rotate(${dir}deg)">
                        >
                            <path d="M10 0 L14 5 L14 18 L12 20 L8 20 L6 18 L6 5 Z"></path>
                            <path stroke-width="1" d="M8 10 L12 10 L12 14 L8 14 Z"></path>
                        </svg>
                    `,
                    iconAnchor:[10,10], iconSize:[20,20]
                });
            } else {
                sondeDivIcon=L.divIcon({className:"transparent-marker-container",
                html:`
                    <div    class="sonde-marker-icon"
                            style="background-color:${getAgeColor(age,0.5)}; border-color:black;   border-width: ${ascAr[0].repfmt=='fm94'?2:0.8}px;">
                    </div>`,
                     iconAnchor:[8,8], iconSize:[15,15]
                });
            }


            //console.log(sondeDivIcon);
            let marker={
                id: d.properties.station_id,
                name: d.properties.name,
                type: d.properties.id_type,
                select: function(){
                    selMarker=marker;//e.target;
                    selMarker.circle._icon.firstElementChild.classList.add("active-marker");
                    thisPlugin.refs.selectSonde.classList.remove("hidden");
                },

                circle: L.marker([lat,lng],{icon:sondeDivIcon, pane:sondeMarkerPane}).addTo(map).on('click',e=>{

                    thisPlugin.open();

                    deselectSelMarker();
                    marker.select();
                    bcast.fire("rqstClose","picker");

                    let [lon,lat,elev]=d.geometry.coordinates;

                    store.set("timestamp",ascAr[0].syn_timestamp*1000);

                    //fire a map click,  which will update the detail plugin if open,   I could not find a way to update the detail position,  without changing the interal code of detail
                    if(W.plugins.detail.isOpen)  {
                        let latlng ={lat,lng:lon,fromMarker:true};
                        map.fire("click",
                            {
                                latlng,
                                layerPoint: map.latLngToLayerPoint(latlng),
                                containerPoint: map.latLngToContainerPoint(latlng)
                            }
                        )
                    }

                    this.refs.titleAscentPage.innerHTML = this.refs.titleMainPage.innerHTML = marker.name;

                    let id=d.properties.station_id,
                        rangeMarkerAr=[],
                        min = ascAr[ascAr.length-1].syn_timestamp,
                        max = ascAr[0].syn_timestamp,
                        dif = max - min;

                    this.refs.ascentsContent.innerHTML="";
                    this.refs.syntimeMarkers.innerHTML="";

                    ascAr = ascAr.filter((a,i,ar)=>     //filter out the older format if within an hour of fm94
                                a.repfmt=="fm94" ||
                                (a.syn_timestamp < (i>0?ar[i-1].syn_timestamp-3600:Infinity) && a.syn_timestamp > (i<ar.length-1?ar[i+1].syn_timestamp+3600:0))
                            );

                    ascAr.forEach((a,i)=>{
                        let dv=document.createElement("div");
                        dv.classList.add("prevAscent", a.repfmt);
                        dv.innerHTML=new Date(a.syn_timestamp*1000).toJSON();
                        this.refs.ascentsContent.appendChild(dv);
                        dv.addEventListener("click",e=>{
                            plotSonde(d.properties.station_id,a);
                            this.refs.ascentsClose.click();
                        })

                        //syn-time range:
                        let mrkr= document.createElement("div");
                        mrkr.classList.add("ascent-range-marker", a.repfmt);
                        if(i==marker.i) mrkr.classList.add("ascent-marker-highlight");
                        mrkr.style.left=100*(a.syn_timestamp-min)/dif+"%";

                        this.refs.syntimeMarkers.appendChild(mrkr);
                        rangeMarkerAr.push(mrkr);

                    })

                    timeRangeVals={id, ascAr, min, max, dif, lat, lon, rangeMarkerAr, marker};

                    coordSel={lat,lon};

                    plotSonde(id, marker.ascAr[marker.i]);
                }),
                age,
                ascAr,  //ascents in summary
                boatPath: !isBoat?null:
                    L.polyline(ascAr,{color:"white", weight:1, opacity:0.6, bubblingMouseEvents:false, interactive:false, }).addTo(map),
                boatPathGhost: !isBoat?null:
                    L.polyline(ascAr,{color:"white", weight:10, opacity:0, bubblingMouseEvents:false, interactive:true, }).addTo(map)
                        .on("click",e=>{
                            //console.log(e);
                            marker.circle.fire("click");
                            onGhostDrag(e.latlng);
                        }),
                i:0
            }

            markers.push(marker);

        });
    });

    let airDataTimePromise =
        getForecast("ecmwf", 0, 0).then(d =>{
            earliestAirDataTime=d.data.data.hours[0] - 90*60*1000;
            reqAge = (Date.now() - earliestAirDataTime) / 3600000;
            return reqAge;
        });

    let sondeinfoPromise = fetch(`https://radiosonde.mah.priv.at/static/sondeinfo.json`).then(r=>r.json()).then(d=>sondeinfo=d);

    //once summary loaded and earliestAirDataTime has loaded:

     Promise.all([airDataTimePromise, summaryPromise(), sondeinfoPromise]).then(r=>{
        //console.log(r[0]);
        $("#radiosonde-range").max= maxAge;
        $("#radiosonde-range").value = maxAge - reqAge;
        //markers.forEach(m=>{
       //     if (m.ascAr[0].syn_timestamp>earliestAirDataTime/1000) m.circle._icon.firstElementChild.style.borderStyle="groove";
       // })
        handleAgeRangeInput();
    })




    /////Bottom slide //I changed it so that the plugin top can be moved down.
    if (rs.isMobile) {
        BottomSlide.instance({
            el: this.refs.slidingX, // Sensitive handler
            pluginEl: this.element,
            pluginName: this.ident,

            ondrag: function (x, y) {
                thisPlugin.element.style.top=(this.startTop+y+10)+"px";
            },

            ondragstart: function (xy) {
                this.startTop=thisPlugin.element.offsetTop;
            },

            ondragend: function() {
                if (this.pluginEl.offsetTop<10){
                    this.pluginEl.style.top="10px";
                } else if (this.pluginEl.offsetHeight<100) {
                    this.pluginEl.style.top="10px";
                    thisPlugin.close();//but not with "unmount"
                }
            }
        });
    }

    ////if touchmove detected on the radiosonde container,  and inside plot area,  then preventDefault which is scrolling,  and consqently allow drag inside.
    $("#radiosonde-container").addEventListener("touchmove", e=>{
        let x=e.targetTouches[0].clientX;
        let y=e.targetTouches[0].clientY;
        let {top,bottom,left,right}= skewt.refs.tooltipRect.getBoundingClientRect();
        if (x>left && x<right && y>top && y<bottom) e.preventDefault();
    }, true);  //capture phase



    const updateDetail4Picker = latlon => {
        this.refs.detail2.innerHTML = `
            Showing forecast data for <b>${store.get("product")}</b> <br>at position: lat ${latlon.lat.toFixed(5)}, lon ${latlon.lon.toFixed(5)}<br>on ${timeString(store.get("timestamp")/1000)}
        `;
    }

    const showProdButtons= latlon =>{       //and update detail when moving picker
        let pointprods=getPointProductsAr(latlon);
        for (let p in prodBtns) {
            prodBtns[p].classList[pointprods.includes(p)?"remove":"add"]("hidden");
        }
    }

    ////place the picker in the defualt popup-pane which is above all the other panes,
    picker.on("pickerOpened", latlon=>{
        deselectSelMarker();
        highlightswitch.set("Forecast");
        $("#radiosonde-zoom").classList.add("hidden");
        showProdButtons(latlon);
        if(!rs.isMobile)$(".leaflet-popup-pane").appendChild($(".picker-content").parentElement);
        pickerPos=latlon;

        //skewt.clear();
        getAirData(prodSel, store.get("timestamp"), latlon.lat, latlon.lon, false);
        updateDetail4Picker(pickerPos);
    })

    picker.on("pickerMoved", latlon=>{
        showProdButtons(latlon);
        pickerPos=latlon;
        getAirData(prodSel, store.get("timestamp"), latlon.lat, latlon.lon, false);
        updateDetail4Picker(pickerPos);
    })

    pickerTools.drag(latlon=>{
        showProdButtons(latlon);
        pickerPos=latlon;
        getAirData( store.get("product"), store.get("timestamp"), latlon.lat, latlon.lon, false);
        updateDetail4Picker(pickerPos);
    }, 400, this.ident);

    picker.on("pickerClosed",()=>{
        if(W.plugins.detail.isOpen) return;
        pickerPos=null;
        if (!selMarker) skewt.clear();
    });

    store.on("timestamp",t=>{
        if (pickerPos){
            getAirData(prodSel, t, pickerPos.lat, pickerPos.lon, false);
        }
    })
    store.on("product",(p,m)=>{
        if(!prodSwitchClicked) prodSwitch.set(p);
        prodSwitchClicked = false;
        if (pickerPos){
            getAirData(prodSel, store.get("timestamp"), pickerPos.lat,pickerPos.lon, false);
            updateDetail4Picker(pickerPos);
        }

    })

    //--manage detail plugin

    const mapClick4Detail = ({latlng:{lat,lng:lon,fromMarker}}) => {
        if (fromMarker) {
            pickerPos=null;
        } else {
            deselectSelMarker();
            pickerPos={lat,lon};
            getAirData(prodSel, store.get("timestamp"), lat, lon, false);
        }
    }

    const detailOpened = p => {
        if (p!=="detail") return;

        bcast.fire("rqstClose","picker");

        //finicky fiddling to get the pogressLine box in the correct position.
        //Intercept the listener in
        //capture phase and make a custom event to be detected by the prgressBar,  with correct pageX and clientX

        let progressLine=$(".progress-line",$("#detail"));
        progressLine.addEventListener("mouseup",e=>{
            if(e.myEvent) return;
            e.stopImmediatePropagation();
            let ev=new Event("mouseup",{bubbles:true})//,cancelable:true,composed:true});
            ev.pageX=e.pageX-(thisPlugin.isOpen?newW:0);
            ev.myEvent=true;
            progressLine.dispatchEvent(ev);
        }, true);
        progressLine.addEventListener("mousemove",e=>{
            if(e.myEvent) return;
            e.stopImmediatePropagation();
            let ev=new Event("mousemove",{bubbles:true})//,cancelable:true,composed:true});
            ev.clientX=e.clientX-(thisPlugin.isOpen?newW:0);
            ev.myEvent=true;
            progressLine.dispatchEvent(ev);
        }, true);

        map.on("click",mapClick4Detail);
    }

    const detailClosed = p =>{
        if (p==="detail"){
            map.off("click",mapClick4Detail);
        }
    }

    //--  Drag border of left pane
    const dragDiv = Object.assign(
        {
            el: $(".drag-right-border"),
            elLine: $(".right-border-line", this.el),

            ondrag: function (x, y) {
                //x and y are values relative to offsetLeft and offsetTop of el (in this case #dragdemo-container)
                //so on drag start: x = this.el.offsetLeft.
                //x = x < 0 ? 0 : x > $("#dragdemo-container").offsetWidth - 22 ? $("#dragdemo-container").offsetWidth - 22 : x;
                //y = y < 0 ? 0 : y > $("#dragdemo-container").offsetHeight - 22 ? $("#dragdemo-container").offsetHeight - 22 : y;
                if (x>300) this.el.style.left = x + "px";
                //this.el.style.top = y + "px";
            },

            ondragstart: function (xy) {
                this.elLine.classList.remove("hidden");
                //xy[0] and xy[1] refers to main window coords.   Available in rest of obj as this.startXY[0] and this.startXY[1].
                //not needed here
            },

            ondragend: function (e) {
                newW=this.el.offsetLeft+5;
                thisPlugin.element.style.width=newW+"px";
                document.head.insertAdjacentHTML('beforeend', `<style> .onwindy-plugin-radiosonde .left-border{left:${newW}px;} </style>`);
                document.head.insertAdjacentHTML('beforeend', `<style> .skew-t .fnt{font:${newW<340?9: newW<400?10: newW<500?11:12}px Arial;} </style>`);
                document.head.insertAdjacentHTML('beforeend', `<style> #windy-plugin-radiosonde{font:${newW<340?9: newW<400?10: newW<500?11:12}px Arial;} </style>`);
                this.elLine.classList.add("hidden");
                setTimeout(skewt.resize,500);
            }
        },
        Drag
    );
    dragDiv._init();




    //-- refresh data not using yet
    function slowTickHandler() {
        // read the directory and check the timestamp on <toplevel>/data/summary.geojson.br
        //
        // the web server is configured to return directory listings as JSON
        // unfortunately mtime comes in RFC1123 format
        fetch(datapath+"summary.geojson").then(r=>r.json()).then(dirlist=>{
        //$.getJSON(toplevel + datadir, function(dirlist) {
            //console.log(dirlist);
            console.log("dirlist", dirlist);
            dirlist.features.forEach(function(entry, index) {
                if (entry.name === summary_br) {
                    var ts = moment.utc(entry.mtime, 'ddd, DD MMM YYYY HH:mm:ss').unix();
                    if (ts > summaryGenerated + 30) {
                        //$.growl.notice({
                        //console.log(      `
                        //    title: "new ascents available",
                        //    message: "click reload to update"
                        //`)
                        //});
                    }
                }
            });
        });
    };
    setInterval(slowTickHandler, 1 * 6e4);

    //-- generate detail
    function genDetail(fc, container) {

        const bold = c => `<b>${c}</b>`;
        const round6 = value => Math.round(value * 1000000) / 1000000;
        const round3 = value => Math.round(value * 1000) / 1000;
        const now= () => Math.floor(Date.now() / 1000);


        var p = fc.properties;
        var i = fc.features.length-1;
        while (fc.features[i].geometry.type != 'Point') {
            i -= 1;
        }
        var lastpt = fc.features[i];

        var para = "<p>";
        var brk = "<br>";
        var detail = container;//document.getElementById(container);
        var html;
        var s = "Station: " + p.station_name;
        if (p.id_type == "mobile")
            s += " (mobile)";
        if (p.id_type == "wmo")
            s += " (WMO id: " + p.station_id + ")";

    ////
        html = bold(s) + para + para;

        var lat, lon, ns, ew;
        if (p.lat > 0) {
            ns = "N";
            lat = p.lat;
        }
        else {
            ns = "S";
            lat = -p.lat;
        }
        if (p.lon > 0) {
            ew = "E";
            lon = p.lon;
        }
        else {
            ew = "W";
            lon = -p.lon;
        }
        html += bold("location:   ") +
            "<a target=\"_blank\" href=\"https://www.google.com/maps/search/?api=1&zoom=12&query=" +
            p.lat + "," + p.lon + "\">" +
            round6(lat) + ns + " " + round6(lon) + ew + " </a>" + brk;

        html += bold("elevation:   ") + p.elevation + "m" + brk;
        html += bold("last recorded height:   ") + Math.round(lastpt.geometry.coordinates[2]) + "m  (" +
        Math.round(lastpt.properties.pressure) + "hPa)" + brk;
        if (p.text)
            html += bold("text:   ") + p.text + brk;

        html += bold("samples:   ") + fc.features.length + brk;

        html += bold("track source:   ");
        if (p.path_source == "origin")
            html += "   GPS";
        if (p.path_source == "simulated")
            html += "   simulated";

        html += brk;
        var rounded_age = Math.round(((now() - p.syn_timestamp) / 3600)*10)/10;
        html += bold("Synoptic time:   ") + timeString(p.syn_timestamp)
        + " (" + rounded_age + " hours old)" +  brk;


        if (p.firstSeen)
            html += bold("First seen:   ") + timeString(p.firstSeen) + brk;
        if (p.lastSeen)
            html += bold("Last seen:   ") + timeString(p.lastSeen) +
            " (" + minsec(p.lastSeen - p.firstSeen) + " later)" + brk;

        if (p.arrived) {
            html += bold("Arrived:   ") + timeString(p.arrived);
        if (p.lastSeen) {
            html +=   " (" + minsec(p.arrived - p.lastSeen) + " after last seen)";
        }
        html += brk;
        }
        if (p.processed) {
            html += bold("Online:   ") + timeString(p.processed) +
                " (" + minsec(p.processed - p.arrived) + " after arrival)" + brk;
        }
        html += para + bold("Sonde:") + brk;
        if (('sonde_type' in p)   && sondeinfo.sonde_types[p.sonde_type])
            html += bold("type:   ") + sondeinfo.sonde_types[p.sonde_type] + brk;
        if (p.sonde_serial)
            html += bold("serial number:   ") + p.sonde_serial + brk;
        if (p.sonde_frequency)
            html += bold("transmit frequency:   ") + round3(p.sonde_frequency / 1000) / 1000 + " MHz" + brk;

        if (p.sonde_swversion)
            html += bold("SW version:   ") + p.sonde_swversion + brk;
        if (('sonde_humcorr' in p) && sondeinfo.sonde_humcorr[p.sonde_humcorr])
            html += bold("humidity correction:   ") + sondeinfo.sonde_humcorr[p.sonde_humcorr] + brk;


        if (('sonde_psensor' in p) && sondeinfo.sonde_psensor[p.sonde_psensor])
            html += bold("pressure sensor:   ") + sondeinfo.sonde_psensor[p.sonde_psensor] + brk;
        if (('sonde_tsensor' in p) && sondeinfo.sonde_tsensor[p.sonde_tsensor])
            html += bold("temperature sensor:   ") + sondeinfo.sonde_tsensor[p.sonde_tsensor] + brk;
        if (('sonde_hsensor' in p) && sondeinfo.sonde_hsensor[p.sonde_hsensor])
            html += bold("humidity sensor:   ") + sondeinfo.sonde_hsensor[p.sonde_hsensor] + brk;
        if (('sonde_humcorr' in p) && sondeinfo.sonde_humcorr[p.sonde_humcorr])
            html += bold("humidity correction:   ") + sondeinfo.sonde_humcorr[p.sonde_humcorr] + brk;

        if (('sonde_gepot' in p) && sondeinfo.sonde_gepot[p.sonde_gepot])
            html += bold("geopotential height:   ") + sondeinfo.sonde_gepot[p.sonde_gepot] + brk;

        if (('sonde_term' in p) && sondeinfo.sonde_term[p.sonde_term])
            html += bold("termination reason:   ") + sondeinfo.sonde_term[p.sonde_term] + brk;

        html += para + bold("Balloon:") + brk;
        if (('balloon_manufacturer' in p) && (p.balloon_manufacturer in  sondeinfo.balloon_manufacturer))
            html += bold("Manufacturer:   ") + sondeinfo.balloon_manufacturer[p.balloon_manufacturer] + brk;

       if (('balloon_type' in p) && sondeinfo.balloon_type[p.balloon_type])
           html += bold("Type:   ") + sondeinfo.balloon_type[p.balloon_type] + brk;

        if ('balloon_weight' in p)
            html += bold("Weight:   ")  +  Math.round(p.balloon_weight*100)/100 + "kg" + brk;

        if (('gas_type' in p) && sondeinfo.gas_type[p.gas_type])
            html += bold("Gas:   ") + sondeinfo.gas_type[p.gas_type] + brk;

        if ('gas_weight' in p)
            html += bold("Gas amount:   ") + Math.round(p.gas_weight*100)/100 + "kg" + brk;


        html += para + bold("Data reference:") + brk;
        if (p.channel)
        html += bold("source:   ") + p.channel + brk;
        html += bold("format:   ") + p.repfmt + "/" + p.encoding + brk;
        if (p.origin_member) {
            if (p.origin_archive) {
                html += bold("source file:  ") + p.origin_member + brk;
            } else {
                html += bold("source file:  ") +
                    "<a  style='text-decoration:underline' href=\"https://radiosonde.mah.priv.at/source/" +
                    p.origin_member  + "\">" +  p.origin_member + " </a>" + brk;
            }
        }

        if (p.origin_archive) {
            html += bold("source archive:  ") +
                "<a  href=\"https://radiosonde.mah.priv.at/source/" +
                p.origin_archive  + "\">" +  p.origin_archive + " </a>" + brk;
        }
        if (p.gts_topic)
            html += bold("GTS topic:   ") + p.gts_topic + brk;
        if (p.fmt)
            html += bold("detail file format:   ") + " version " + p.fmt + brk;

        detail.innerHTML = html;
    }


    document.addEventListener("keydown",k=>{
        if(k.key=="ArrowRight" || k.key=="ArrowLeft"){
            if($(":hover",this.refs.syntimeRangeCont)){
                k.stopImmediatePropagation();
            }
        }
    },  true);

</script>
</plugin>